#! title:  "三脚猫 profiling"
tags:

  - HPC

#! meta end

本博客应当有更多的随手记的小东西！正好最近做某课程大作业的时候遇到了一些好玩的关于profiling的东西，简单记录一下。不过我对profiling并不太熟，这篇文章也就是随便写写，实在是三脚猫水平。

期末课程大作业，（我们选了一个）题目是某个计算密集型程序的性能优化。我们小组里面已经有一个同学做了一部分，因此在他的基础上继续做一些改进并测一些数据就可以交了。这个程序上我们已经做了一些算法上的优化和ARM上的SIMD优化。

## 开个机子

不难猜出，这位同学使用了ARM，是因为他的笔记本是Apple Silicon。准确地说是M1。可惜我手头上能摸到的ARM的机子只有一台树莓派。拿来做性能测试还是算了吧。

因此我计划开一台ARM的VPS。众所周知，近些年来ARM的VPS是越来越多了，不过我并没有开众所周知的Oracle（似乎好像也不好开），而是开了台Hetzner的ARM VPS，不用比价就知道他家的不贵。

当时我在群里面简单说了这个事情，最开始是想问群友能不能借到物理机给开个访问，毕竟VPS是共享核的可能性能测不准。想了想还是算了，整个这玩意还挺麻烦的，所以还是自己开了台VPS。这时候神神群友cyy发出了提醒："aws上性能计数器没有限制，其他比如azure是有限制的"。我并不是特别了解profiling的原理，但是根据我的猜测，我感觉只是简单打点采样的话似乎没有什么影响？

当我开了机装好依赖编译好程序后，我就知道我错了。作为啥都不懂的老东西，我开局就是一个-pg用gprof。跑程序没什么问题，看gmon.out就发现：

```
Each sample counts as 0.01 seconds.
 no time accumulated
```

我还在想是不是ARM平台上gprof的问题。稍微咨询了一下GPT，换用了perf（对我之前还真没用过；我用过callgrind但是印象里这玩意有显著性能损失不好用）。可惜跑出来后还是什么都没有。这时候我感觉就是云厂商的限制了。我前面在咨询GPT为什么报错和输出为空的时候GPT并没有提到可能是这个原因，专门指出了是VPS后才提到，可能会因为虚拟化技术限制而导致无法使用性能计数器，进而导致不能跑profiling。GPT专门指出很多很多家的VPS是可以用的，可惜hz和az不行。比较难绷的是，网上好像很难查到相关信息。还好有神神cyy，不然我又要蒙古好一阵。

## 乞讨环境

考虑到其他家的机子也都不是很便宜，我也懒得去一个一个开测试了。最后还是选择了向群友乞讨。此时正好有一个家有Mac Mini的神神群友在线，可以把机子借我用。

之后考虑怎么把机子给我。显然最方便的方式是开一个Docker，用ssh连进去。不过这位群友在怀疑我会不会搞Docker逃逸，因此只给我了个普通用户，就是得多次麻烦他帮忙装几个软件了。普通用户还是能跑profiling的，只是可能需要给开一个ptrace_scope的内核选项，虽然默认值的应该也是能用的？perf_event_paranoid可能也需要改一下。

简单调一下后，发现还是用不了。发现报错：

```
perf_event_open(..., PERF_FLAG_FD_CLOEXEC) failed with unexpected error 1 (Operation not permitted)
perf_event_open(..., 0) failed unexpectedly with error 1 (Operation not permitted)
```

这个问题倒是不难查到。Docker内部默认是跑不了profiling的，把相关权限给默认关掉了。给Docker启动命令里面加个seccomp选项，问一下GPT就行。简单添加一个`--cap-add=CAP_PERFMON`。跑起来后测试了一下，普通用户也确实能跑了。可以开始整大作业的测试项目了。

## 简单跑跑

简单的跑了一下profiling。和项目题目有关的结论就不用说了。由于是做性能测试，所有编译都是开的O3选项。

跑的时候观测到有趣的现象，发现我编译出来的未优化版本要比原作者的要快不少，而开满优化版本略慢。我最开始还以为是什么桌面版的M1比较厉害，但是开满优化版本更慢这个没法解释。精细调整了一下不同优化的编译开关，发现我自己测的，某些SIMD开关的效果并不显著。我直接就想到了编译器问题。我Docker开的环境是Debian，编译器用的是gcc-12。这又一次完美印证了刻板印象：gcc会主动去做SIMD优化，只可惜他做的还是比我们手工做要差一点。而原作者的测试环境是MacOS，显然编译器是clang。我又用clang-14测了一下，数据确实就基本一致了，满优化版本也比gcc的要快（又一次验证了gcc优化水平不如clang的刻板印象）。但clang-16编译出来的反而更慢了。

简单跑了跑测试后，稍微改了点代码，作业就混完了。不过把profiling跑起来的过程还挺奇妙的。